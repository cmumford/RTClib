/**
 * @section license License
 *
 * This file is subject to the terms and conditions defined in
 * file 'license.txt', which is part of this source code package.
 *
 * This is a fork of Adafruit's RTClib library.
 * https://github.com/adafruit/RTClib
 */

#ifndef RTC_DATETIME_H_
#define RTC_DATETIME_H_

#include <cstdint>
#include <string>

#include "rtclib/constants.h"

namespace rtc {

class TimeSpan;

/**************************************************************************/
/*!
    @brief  Simple general-purpose date/time class (no TZ / DST / leap
            seconds).

    This class stores date and time information in a broken-down form, as a
    tuple (year, month, day, hour, minute, second). The day of the week is
    not stored, but computed on request. The class has no notion of time
    zones, daylight saving time, or
    [leap seconds](http://en.wikipedia.org/wiki/Leap_second): time is stored
    in whatever time zone the user chooses to use.

    The class supports dates in the range from 1 Jan 2000 to 31 Dec 2099
    inclusive.
*/
/**************************************************************************/
class DateTime {
 public:
  DateTime(uint32_t t = SECONDS_FROM_1970_TO_2000);
  DateTime(uint16_t year,
           uint8_t month,
           uint8_t day,
           uint8_t hour = 0,
           uint8_t min = 0,
           uint8_t sec = 0);
  DateTime(const DateTime& copy);
  DateTime(const char* date, const char* time);
  // DateTime(const char* date, const char* time);
  DateTime(const char* iso8601date);
  bool isValid() const;
  char* toString(char* buffer);

  /**
   * Return the year.
   * @return Year (range: 2000--2099).
   */
  uint16_t year() const { return 2000U + yOff; }

  /**
   * Return the month.
   *
   * @return Month number (1--12).
   */
  uint8_t month() const { return m; }

  /**
   * Return the day of the month.
   *
   * @return Day of the month (1--31).
   */
  uint8_t day() const { return d; }

  /**
   * Return the hour.
   *
   * @return Hour (0--23).
   */
  uint8_t hour() const { return hh; }

  uint8_t twelveHour() const;

  /**
   * Return whether the time is PM.
   *
   * @return 0 if the time is AM, 1 if it's PM.
   */
  uint8_t isPM() const { return hh >= 12; }

  /**
   * Return the minute.
   *
   * @return Minute (0--59).
   */
  uint8_t minute() const { return mm; }

  /**
   * Return the second.
   *
   * @return Second (0--59).
   */
  uint8_t second() const { return ss; }

  uint8_t dayOfTheWeek() const;

  /* 32-bit times as seconds since 2000-01-01. */
  uint32_t secondstime() const;

  /* 32-bit times as seconds since 1970-01-01. */
  uint32_t unixtime(void) const;

  /**
   * Format of the ISO 8601 timestamp generated by `timestamp()`.
   *
   * Each option corresponds to a `toString()` format as follows:
   */
  enum timestampOpt {
    TIMESTAMP_FULL,  //!< `YYYY-MM-DDThh:mm:ss`
    TIMESTAMP_TIME,  //!< `hh:mm:ss`
    TIMESTAMP_DATE   //!< `YYYY-MM-DD`
  };
  std::string timestamp(timestampOpt opt = TIMESTAMP_FULL) const;

  DateTime operator+(const TimeSpan& span);
  DateTime operator-(const TimeSpan& span);
  TimeSpan operator-(const DateTime& right);
  bool operator<(const DateTime& right) const;

  /**
   * Test if one DateTime is greater (later) than another.
   *
   * @warning if one or both DateTime objects are invalid, returned value is
   *          meaningless
   * @see use `isValid()` method to check if DateTime object is valid
   * @param right DateTime object to compare
   * @return True if the left DateTime is later than the right one,
   *     false otherwise
   */
  bool operator>(const DateTime& right) const { return right < *this; }

  /**
   *  Test if one DateTime is less (earlier) than or equal to another
   *
   *  @warning if one or both DateTime objects are invalid, returned value is
   *           meaningless
   *  @see use `isValid()` method to check if DateTime object is valid
   *  @param right DateTime object to compare
   *  @return True if the left DateTime is earlier than or equal to the
   *          right one, false otherwise
   */
  bool operator<=(const DateTime& right) const { return !(*this > right); }

  /**
   * Test if one DateTime is greater (later) than or equal to another.
   *
   * @warning if one or both DateTime objects are invalid, returned value is
   *          meaningless.
   * @see use `isValid()` method to check if DateTime object is valid
   * @param right DateTime object to compare
   * @return True if the left DateTime is later than or equal to the right
   *         one, false otherwise.
   */
  bool operator>=(const DateTime& right) const { return !(*this < right); }
  bool operator==(const DateTime& right) const;

  /**
   *  Test if two DateTime objects are not equal.
   *
   *  @warning if one or both DateTime objects are invalid, returned value is
   *           meaningless.
   *  @see use `isValid()` method to check if DateTime object is valid
   *  @param right DateTime object to compare
   *  @return True if the two objects are not equal, false if they are
   */
  bool operator!=(const DateTime& right) const { return !(*this == right); }

 protected:
  uint8_t yOff;  ///< Year offset from 2000
  uint8_t m;     ///< Month 1-12
  uint8_t d;     ///< Day 1-31
  uint8_t hh;    ///< Hours 0-23
  uint8_t mm;    ///< Minutes 0-59
  uint8_t ss;    ///< Seconds 0-59
};

}  // namespace rtc

#endif  // RTC_DATETIME_H_
